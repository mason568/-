# 笔试题目
这个是我们机考的经验和练习题网站

常考知识点：
- 基本操作：输入输出处理（重点），字符串操作与ASCii码（重点）
- 数据结构：一维数组，栈，队列
- 编程思想：暴力法（重点），递归
- 算法：排列组合（重点），快速排序（重点），二分查找，位运算，滑动窗口，深度优先搜索（进阶），广度优先搜索（进阶），搜索回溯（进阶）

登录牛客网华为机试专栏练习并熟悉机试环境：https://www.nowcoder.com/ta/huawei
# 机考辅导
1. 需要开摄像头，不能访问其他网页或查找资源，可以在本地IDE调试好后拷贝到牛客网上再调试
2. 多刷一下各种类型算法题，难度中等及以上，在牛客有或力扣上刷都可以
3. 熟悉牛客网考试环境，和本地IDE，力扣有差异
4. ACM模式，需要解决输入输出
5. 一定不要死磕某一题，三题得分加起来达到及格分即可

# 逐个击破
## 牛客网环境check
输入输出处理
1. 核心代码模式处理
不需要处理任何输入输出，直接返回值即可。
2. ACM 模式
你的代码需要处理输入输出，请使用如下样例代码读取输入和打印输出：


```
#include <iostream>
using namespace std;

int main() {
    int a, b;
    while (cin >> a >> b) { // 注意 while 处理多个 case 。 这个while以后用起来
        cout << a + b << endl;
    }
}
// 64 位输出请用 printf("%lld")
```

> 华为机试题目：https://www.nowcoder.com/ta/huawei

> python解法过目：https://pycoder.blog.csdn.net/article/details/124648380

## 刷题
loading...

## 总结

### 数据结构
- set和map的key是有序的 unorder_set和unorder_map无序，需要不同的头文件，另外，multimap和multiset的key允许重复， key有序
> 参考：https://www.cnblogs.com/PiaYie/p/15877059.html

- string常用方法
> https://blog.csdn.net/qq_37954088/article/details/82286530


#### 一些注意的点
1. int类型转换来做浮点数的四舍五入
```
int main() {
	float a;

	while (cin >> a) {
		if (a > 0) {
			cout << int(a + 0.5) << endl;
		}
	}

	return 0;
}
```

### 输入输出处理
##### 输入原理

程序的输入都有一个缓冲区，即输入缓冲区。一次输入过程是这样的，当一次键盘输入结束时会将输入的数据存入输入缓冲区，而cin对象直接从输入缓冲区中取数据。正因为cin对象是直接从缓冲区取数据的，所以有时候当缓冲区中有残留数据时，cin对象会直接取得这些残留数据而不会请求键盘输入

#### cin的说明 
> 参考 https://blog.csdn.net/selina8921/article/details/79067941
- 该操作符是根据后面变量的类型读取数据。
- 输入结束条件 ：遇到Enter、Space、Tab键。
- 当cin>>从缓冲区中读取数据时，若缓冲区中第一个字符是空格、tab或换行这些分隔符时，cin>>会将其忽略并清除，继续读取下一个字符，若缓冲区为空，则继续等待。但是如果读取成功，字符后面的分隔符是残留在缓冲区的，cin>>不做处理。

#### cout的说明
> 输入一个字符串不带空格 和一个变量
- cout.width(8);
>控制 **下一次** cout输出宽度至少大于等于8
- cout.fill('0');
> **下一次** cout输出不够就填充0
- cout << left << "asdasdas"<< endl; 
> 本次左对齐

#### 技巧
1. 若要读取单个字符，直接cin.get(char ch)或ch=cin.get()即可
> cin.get()的返回值是int类型，成功：读取字符的ASCII码值，遇到文件结束符时，返回EOF，即-1，Windows下标准输入输入文件结束符为Ctrl+z，Linux为Ctrl+d。
2. cin.get(str,size);读取一行时，只能将字符串读入C风格的字符串中，即char*，但是C++的getline函数还可以将字符串读入C++风格的字符串中，即string类型。


3. while(cin>>s);

注意 while 处理多个 case。退出方法：回车后，在新行Ctrl+z并回车。若输入数据后Ctrl+z再回车无效。
> 这是因为：https://blog.csdn.net/qq_41543888/article/details/102766294

4. ch = toupper(getchar())
> tolower()/toupper()   c++内建函数
```
int tolower(int c)
{
	if ((c >= 'A') && (c <= 'Z'))
		return c + ('a' - 'A');
	return c;
}
 
int toupper(int c)
{
	if ((c >= 'a') && (c <= 'z'))
		return c + ('A' - 'a');
	return c;
}
```

5. 读取一行用cin.get(a, 5);
> cin.get(数组名，长度，[结束符]) 结束符可选,默认回车Enter

> 对结束符处理：不丢弃缓冲区中的Enter（自定义结束符时同样不丢弃缓冲区中的结束符）

> 会在读取的字符串后面自动加上'\0'

```
#include<iostream>
using namespace std;
int main(void){
  char ch='a',a[20];
  cin.get(a,5);
  cin.get(ch);
  cout<<a<<"--"<<(int)ch<<endl;  Enter 的ascii为10
return 0;
}

输入：
1 23回车
输出:
1 23--10
```
6. 读取一行用getline
> cin.getline(数组名，长度，[结束符]) 结束符可选,默认回车Enter, i.e., '\n'

> getline()的原型是 istream& getline ( istream &is , string &str , char delim ); 
>> cin就是一个输入流

> 会在读取的字符串后面自动加上'\0'


7. 鉴于getline较cin.get()的优点，建议使用getline进行行的读取。区别：

- cin.get()当输入的字符串超过规定长度时，不会引起cin函数的错误，后面的cin操作会继续执行，只是直接从缓冲区中取数据。

但是cin.getline()当输入超过规定长度时，会引起cin函数的错误，后面的cin操作将不再执行。


当输入的字符数大于count时，则get函数只读取count-1个字符，而其余的字符仍然保存在缓冲区中，还可再对其进行读取；

但是函数getline则不然，getline()会设置失效位(faibit)，并且关闭后面的输入，这个时候再 用ch=cin.get()是读取不到留在输入队列中的字符的。
可以用下面的命 令来恢复输入：

cin.clear()； //因为clear()会重置失效位，打开输入。这个时候ch=cin.get();就可以读取留在输入队列中的字符。
- cin.get读取一行时，遇到换行符(自定义结束符)时结束读取，但是不对换行符(自定义结束符)进行处理，换行符(自定义结束符)仍然残留在输入缓冲区。

**getline读取一行字符时，默认遇到’\n’(自定义结束符)时终止，并且将’\n’(自定义结束符)直接从输入缓冲区中删除掉，不会影响下面的输入处理**。

两者都会在读取的字符串后面自动加上'\0'

- cin.get(str,size);读取一行时，只能将字符串读入C风格的字符串中，即char*，但是C++的getline函数还可以将字符串读入C++风格的字符串中，即string类型。（string test; getline(cin,test);）


8. 清楚缓冲区的4种办法
  
https://blog.csdn.net/cpp_learner/article/details/104178769?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-104178769-blog-79067941.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-104178769-blog-79067941.pc_relevant_default&utm_relevant_index=1





### 字符串操作与ascii码
1. 字符串中的某一个字串全替换为另一个串
```
string& replace_all(string& src, const string& old_value, const string& new_value) {
	// 每次重新定位起始位置，防止上轮替换后的字符串形成新的old_value
	for (string::size_type pos(0); pos != string::npos; pos += new_value.length()) {
		if ((pos = src.find(old_value, pos)) != string::npos) {
			src.replace(pos, old_value.length(), new_value);
		}
		else break;
	}
	return src;

}
```
2. 即使str字符串长度不足8，str.substr(0, 8)也能正常获取剩余的字符，不会报错。
```
int main()
{
	string str;
	cin >> str;
	cout << str.substr(0, 8) << endl;
	return 0;
}
```

3. 字符串转数值，可以用内建函数如 stoll stoi stof stod
> int stoi (const string& str, size_t* idx = 0, int base = 10); base 默认值为10即以十进制解析， idx默认为 nullptr即可，表示从后面碰到数值的第一个字符开始解析




```
int main() {
	string str;
	while (cin >> str) {
		cout << stoi(str,nullptr,0) << endl;
	}

	return 0;
}
```

4. 自己按照逻辑实现进制转换
![十六进制转10进制](https://github.com/mason568/HW_nowcode_Note/blob/master/HUAWEI_Python_IDE/stoi_str_nullptr_0.gif)
    - 十六进制转10进制 输入 '0xAAA'  \to  int32
    > 使用pow函数要加头文件< cmath > 不然过不了编译
    ```
    #include<iostream>
    #include<string>
    #include<cmath>
    using namespace std;

    int main() {
        string str;
        while (cin >> str) {
            int pow_up_num = 0;
            int res = 0;
            for (int i = str.size() - 1; i > 1; i --) {
                if(str[i] >= '0' && str[i] <= '9')
                {
                    res += (str[i] - '0') * pow(16, pow_up_num);
                    pow_up_num++;
                }
                else if(str[i] >= 'A' && str[i] <= 'F'){
                    res += (str[i] - 'A'+10) * pow(16, pow_up_num);
                    pow_up_num++;
                }
                else if (str[i] >= 'a' && str[i] <= 'f') {
                    res += (str[i] - 'a'+10) * pow(16, pow_up_num);
                    pow_up_num++;
                }
                else {
                    cout << "error input!" << endl;
                    exit(-1);
                }
            }
            cout << res << endl;

        }

        return 0;
    }
    ```

5. 字符串反转
    - 内建函数reverse(s,s.begin(),s.end());记得加头文件#include< algorithm.h >
    - 自己实现reverse函数
```
    void reverse_string(string& s, int start, int end) {
        while (start < end) {
            swap(s[start++], s[end--]);
        }
    }
```

6. 使用排序算法sort(s.begin(), s.end());时候记得加头文件#include< algorithm.h >

7. 单词字典序
```
#include<iostream>
#include<string>
#include<vector>
#include<algorithm>

using namespace std;
int main() {
	int N;
	while (cin >> N) {
		//vector<string> res;
		vector<string> s;
		for (int i = 0; i < N; i++) {
			string str;
			cin >> str;
			s.push_back(str);
		}
		sort(s.begin(), s.end()); // str1 > str2 可以这样对比字符串单词字典序
		for (auto a : s) {
			cout << a << endl;
		}
	}


	return 0;
}
```


### 暴力破解
1. 质数分解定理
> https://www.cnblogs.com/wellerency/p/15868807.html


![质数分解定理](https://github.com/mason568/HW_nowcode_Note/blob/master/HUAWEI_Python_IDE/%E8%B4%A8%E6%95%B0%E5%88%86%E8%A7%A3%E5%AE%9A%E7%90%86.png)
- 判定质数和分解质因数
- 边界条件可选 
  - i <= sqrt(N)
  - i <= N/i
```
#include<iostream>
#include<vector>
using namespace std;


//质数分解定理 一个大于1的数其质数分解形式是唯一的。
int main() {

	int N;
	//vector<int> res;
	while (cin >> N) {
		if (N == 1) {
			cout << N << " " << N << endl;
		}
		
		for (int i = 2; i <= N / i; i++) {
			//M*能够整除i
			if (N % i == 0) {
				int cnt = 0;
				while (N % i == 0) {
					cnt++;
					//s.push_back(i);
					N /= i;
					//if (cnt) cout << i << " " << cnt << endl;
					if (cnt) cout << i << " ";
				}
			}
		}
		//if (N > 1) cout << N << " " << 1<< endl;
		if (N > 1) cout << N << endl;
	
	}

	return 0;
}

```
### 快速排序
> 经典排序算法总结：https://www.cnblogs.com/fnlingnzb-learner/p/9374732.html

> 经典排序算法总结（动图）：https://www.cnblogs.com/onepixel/articles/7674659.html

1. 冒泡排序法 $O(n^2)$
![冒牌排序法思路图](https://github.com/mason568/HW_nowcode_Note/blob/master/HUAWEI_Python_IDE/mppxf.gif)
```
//冒泡排序
void BubbleSort(int* h, size_t len)
{
    if (h == NULL) return;
    if (len <= 1) return;
    //i是次数，j是具体下标
    for (int i = 0; i < len - 1; ++i)
        for (int j = 0; j < len - 1 - i; ++j)
            if (h[j] > h[j + 1])
                Swap(h[j], h[j + 1]);

    return;
}
```


1. 快速排序 $O(n\log_2 n)$
   - 内建函数 sort(s.begin(), s.end()); 是algorithm中的函数需要头文件
   - 自己实现
```
//快速排序，随机选取哨兵放前面
void QuickSort(int* h, int left, int right)
{
    if (h == NULL) return;
    if (left >= right) return;

    //防止有序队列导致快速排序效率降低
    srand((unsigned)time(NULL));  // include"time.h"
    int len = right - left;
    int kindex = rand() % (len + 1) + left;
    Swap(h[left], h[kindex]);

    int key = h[left], i = left, j = right;
    while (i < j)
    {
        while (h[j] >= key && i < j) --j;
        if (i < j) h[i] = h[j];
        while (h[i] < key && i < j) ++i;
        if (i < j) h[j] = h[i];
    }

    h[i] = key;

    QuickSort(h, left, i - 1);
    QuickSort(h, j + 1, right);
}
```

### 排列组合
### 二分查找
### 递归
### 位运算
### 滑动窗口
### 深度优先算法
### 广度优先算法
### 搜索回溯


# 其它学习资料
B站视频与CSDN文章配套资料工具源码地址：https://docs.qq.com/doc/DVGlCZXlqTmRlWGhS


> 全套工具包
>> 链接：https://pan.baidu.com/s/1gCTYsSKchwFJQqJ1hY5AxA 
提取码：oviy

> 网络安全web安全视频教程
>> 链接：https://pan.baidu.com/s/1_keEevAmsTsgnddZ9FRqBQ 
提取码：9kbb 

> 面试题、CTF、攻防渗透、SRC
>>链接：https://pan.baidu.com/s/1isjXQIzoImpW5lKCSyiygw 
提取码：qa3t 

>>链接：https://pan.baidu.com/s/1kWFpnnYSt3zYQVxUQKLQWA 
提取码：tmd9 

>>链接：https://pan.baidu.com/s/1sY_0PPu3prFf2NWG1DREzA 
提取码：xbmo 

>>链接：https://pan.baidu.com/s/1DRlaAoCTaM9yskW1ct3Eow 
提取码：jzws

>>链接：https://pan.baidu.com/s/19mQOoaOTK-KtH-kxF3T4PA 
提取码：6yzd

> 忍着安全系统
>>链接：https://pan.baidu.com/s/1n28NC1x9aaRouBocb70BUg?pwd=qgv7 
提取码：qgv7 

>v2022网络安全学习路线图：
>>链接：https://www.processon.com/view/link/62b1b2267d9c08073c671315

>安全搜索语法
>>链接：https://pan.baidu.com/s/1ep1nF0iN9WB0qF-Ejvma4w?pwd=u1jt 
提取码：u1jt 

>网络安全PPT全套
>>链接：https://pan.baidu.com/s/1VFm9oNub-1qDQbe3zsPDwg 
提取码：8888 

>安全攻防笔记
>>链接：https://pan.baidu.com/s/19PT6-eAh9mqWKYHSLVhSqA?pwd=k2aw 
提取码：k2aw 

>《B站资料整理》
>>链接：https://shimo.im/docs/gO3ox4MWwGFvy7qD/ 
