# 笔试题目
这个是我们机考的经验和练习题网站

常考知识点：
- 基本操作：输入输出处理（重点），字符串操作与ASCii码（重点）
- 数据结构：一维数组，栈，队列
- 编程思想：暴力法（重点），递归
- 算法：排列组合（重点），快速排序（重点），二分查找，位运算，滑动窗口，深度优先搜索（进阶），广度优先搜索（进阶），搜索回溯（进阶）

登录牛客网华为机试专栏练习并熟悉机试环境：https://www.nowcoder.com/ta/huawei
# 机考辅导
1. 需要开摄像头，不能访问其他网页或查找资源，可以在本地IDE调试好后拷贝到牛客网上再调试
2. 多刷一下各种类型算法题，难度中等及以上，在牛客有或力扣上刷都可以
3. 熟悉牛客网考试环境，和本地IDE，力扣有差异
4. ACM模式，需要解决输入输出
5. 一定不要死磕某一题，三题得分加起来达到及格分即可

# 逐个击破
## 牛客网环境check
输入输出处理
1. 核心代码模式处理
不需要处理任何输入输出，直接返回值即可。
2. ACM 模式
你的代码需要处理输入输出，请使用如下样例代码读取输入和打印输出：


```
#include <iostream>
using namespace std;

int main() {
    int a, b;
    while (cin >> a >> b) { // 注意 while 处理多个 case 。 这个while以后用起来
        cout << a + b << endl;
    }
}
// 64 位输出请用 printf("%lld")
```

> 华为机试题目：https://www.nowcoder.com/ta/huawei

> python解法过目：https://pycoder.blog.csdn.net/article/details/124648380

## 刷题
loading...

## 总结

### 数据结构
1. set和map的key是有序的 unorder_set和unorder_map无序，需要不同的头文件，另外，multimap和multiset的key允许重复， key有序
> 参考：https://www.cnblogs.com/PiaYie/p/15877059.html

2. string常用方法
> https://blog.csdn.net/qq_37954088/article/details/82286530

3. [在c++中谨慎用int](https://zhuanlan.zhihu.com/p/272570386#:~:text=%E8%AD%A6%E5%91%8A%20C26451%20%E7%AE%97%E6%9C%AF%E6%BA%A2%E5%87%BA%3A%20%E4%BD%BF%E7%94%A8%204%20%E5%AD%97%E8%8A%82%E5%80%BC%E4%B8%8A%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%20%2B,%EF%BC%8C%E7%84%B6%E5%90%8E%E5%B0%86%E7%BB%93%E6%9E%9C%E8%BD%AC%E6%8D%A2%E5%88%B0%208%20%E5%AD%97%E8%8A%82%E5%80%BC%E3%80%82%20%E5%9C%A8%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%20%2B%20%E4%B9%8B%E5%89%8D%E5%B0%86%E5%80%BC%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AE%BD%E7%B1%BB%E5%9E%8B%E5%8F%AF%E9%81%BF%E5%85%8D%E6%BA%A2%E5%87%BA%20%28io.2%29%E3%80%82%20%E8%BF%99%E6%98%AF64%E4%BD%8D%E5%92%8C32%E4%BD%8D%E6%95%B4%E5%9E%8B%E5%AE%BD%E5%BA%A6%E4%B8%8D%E5%AF%B9%E9%BD%90%E7%9A%84%E8%AD%A6%E5%91%8A%E3%80%82)

> 这个整型变量会参与到地址运算吗？(对于整型变量这非常常见，例如用作数组以及stl的索引)，如果是，那么不要用int了。
> 
> 在索引访问、指针地址相关的运算上，使用ptrdiff_t和unsigned_int，应当是规范的C++的统一标准。否则混用的话，必然会出现大片的编译器警告，并且降低程序效率。

#### 一些注意的点
1. int类型转换来做浮点数的四舍五入
```
int main() {
	float a;

	while (cin >> a) {
		if (a > 0) {
			cout << int(a + 0.5) << endl;
		}
	}

	return 0;
}
```

### 输入输出处理
##### 输入原理

程序的输入都有一个缓冲区，即输入缓冲区。一次输入过程是这样的，当一次键盘输入结束时会将输入的数据存入输入缓冲区，而cin对象直接从输入缓冲区中取数据。正因为cin对象是直接从缓冲区取数据的，所以有时候当缓冲区中有残留数据时，cin对象会直接取得这些残留数据而不会请求键盘输入

#### cin的说明 
> 参考 https://blog.csdn.net/selina8921/article/details/79067941
- 该操作符是根据后面变量的类型读取数据。
- 输入结束条件 ：遇到Enter、Space、Tab键。
- 当cin>>从缓冲区中读取数据时，若缓冲区中第一个字符是空格、tab或换行这些分隔符时，cin>>会将其忽略并清除，继续读取下一个字符，若缓冲区为空，则继续等待。但是如果读取成功，字符后面的分隔符是残留在缓冲区的，cin>>不做处理。

#### cout的说明
> 输入一个字符串不带空格 和一个变量
- cout.width(8);
>控制 **下一次** cout输出宽度至少大于等于8
- cout.fill('0');
> **下一次** cout输出不够就填充0
- cout << left << "asdasdas"<< endl; 
> 本次左对齐

#### 技巧
1. 若要读取单个字符，直接cin.get(char ch)或ch=cin.get()即可
> cin.get()的返回值是int类型，成功：读取字符的ASCII码值，遇到文件结束符时，返回EOF，即-1，Windows下标准输入输入文件结束符为Ctrl+z，Linux为Ctrl+d。
2. cin.get(str,size);读取一行时，只能将字符串读入C风格的字符串中，即char*，但是C++的getline函数还可以将字符串读入C++风格的字符串中，即string类型。


3. while(cin>>s);

注意 while 处理多个 case。退出方法：回车后，在新行Ctrl+z并回车。若输入数据后Ctrl+z再回车无效。
> 这是因为：https://blog.csdn.net/qq_41543888/article/details/102766294

4. ch = toupper(getchar())
> tolower()/toupper()   c++内建函数
```
int tolower(int c)
{
	if ((c >= 'A') && (c <= 'Z'))
		return c + ('a' - 'A');
	return c;
}
 
int toupper(int c)
{
	if ((c >= 'a') && (c <= 'z'))
		return c + ('A' - 'a');
	return c;
}
```

5. 读取一行用cin.get(a, 5);
> cin.get(数组名，长度，[结束符]) 结束符可选,默认回车Enter

> 对结束符处理：不丢弃缓冲区中的Enter（自定义结束符时同样不丢弃缓冲区中的结束符）

> 会在读取的字符串后面自动加上'\0'

```
#include<iostream>
using namespace std;
int main(void){
  char ch='a',a[20];
  cin.get(a,5);
  cin.get(ch);
  cout<<a<<"--"<<(int)ch<<endl;  Enter 的ascii为10
return 0;
}

输入：
1 23回车
输出:
1 23--10
```
6. 读取一行用getline
> cin.getline(数组名，长度，[结束符]) 结束符可选,默认回车Enter, i.e., '\n'

> getline()的原型是 istream& getline ( istream &is , string &str , char delim ); 
>> cin就是一个输入流

> 会在读取的字符串后面自动加上'\0'


7. 鉴于getline较cin.get()的优点，建议使用getline进行行的读取。区别：

- cin.get()当输入的字符串超过规定长度时，不会引起cin函数的错误，后面的cin操作会继续执行，只是直接从缓冲区中取数据。

但是cin.getline()当输入超过规定长度时，会引起cin函数的错误，后面的cin操作将不再执行。


当输入的字符数大于count时，则get函数只读取count-1个字符，而其余的字符仍然保存在缓冲区中，还可再对其进行读取；

但是函数getline则不然，getline()会设置失效位(faibit)，并且关闭后面的输入，这个时候再 用ch=cin.get()是读取不到留在输入队列中的字符的。
可以用下面的命 令来恢复输入：

cin.clear()； //因为clear()会重置失效位，打开输入。这个时候ch=cin.get();就可以读取留在输入队列中的字符。
- cin.get读取一行时，遇到换行符(自定义结束符)时结束读取，但是不对换行符(自定义结束符)进行处理，换行符(自定义结束符)仍然残留在输入缓冲区。

**getline读取一行字符时，默认遇到’\n’(自定义结束符)时终止，并且将’\n’(自定义结束符)直接从输入缓冲区中删除掉，不会影响下面的输入处理**。

两者都会在读取的字符串后面自动加上'\0'

- cin.get(str,size);读取一行时，只能将字符串读入C风格的字符串中，即char*，但是C++的getline函数还可以将字符串读入C++风格的字符串中，即string类型。（string test; getline(cin,test);）


8. [清楚缓冲区的4种办法](https://blog.csdn.net/cpp_learner/article/details/104178769?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-104178769-blog-79067941.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-104178769-blog-79067941.pc_relevant_default&utm_relevant_index=1)






### 字符串操作与ascii码
1. 字符串中的某一个字串全替换为另一个串
```
string& replace_all(string& src, const string& old_value, const string& new_value) {
	// 每次重新定位起始位置，防止上轮替换后的字符串形成新的old_value
	for (string::size_type pos(0); pos != string::npos; pos += new_value.length()) {
		if ((pos = src.find(old_value, pos)) != string::npos) {
			src.replace(pos, old_value.length(), new_value);
		}
		else break;
	}
	return src;

}
```
2. 即使str字符串长度不足8，str.substr(0, 8)也能正常获取剩余的字符，不会报错。
```
int main()
{
	string str;
	cin >> str;
	cout << str.substr(0, 8) << endl;
	return 0;
}
```

3. 字符串转数值，可以用内建函数如 stoll stoi stof stod
> int stoi (const string& str, size_t* idx = 0, int base = 10); base 默认值为10即以十进制解析， idx默认为 nullptr即可，表示从后面碰到数值的第一个字符开始解析




```
int main() {
	string str;
	while (cin >> str) {
		cout << stoi(str,nullptr,0) << endl;
	}

	return 0;
}
```

4. 自己按照逻辑实现进制转换
![十六进制转10进制](牛客网华为机试题IDE\HUAWEI_Python_IDE\stoi_str_nullptr_0.gif)
    - 十六进制转10进制 输入 '0xAAA'  \to  int32
    > 使用pow函数要加头文件< cmath > 不然过不了编译
    ```
    #include<iostream>
    #include<string>
    #include<cmath>
    using namespace std;

    int main() {
        string str;
        while (cin >> str) {
            int pow_up_num = 0;
            int res = 0;
            for (int i = str.size() - 1; i > 1; i --) {
                if(str[i] >= '0' && str[i] <= '9')
                {
                    res += (str[i] - '0') * pow(16, pow_up_num);
                    pow_up_num++;
                }
                else if(str[i] >= 'A' && str[i] <= 'F'){
                    res += (str[i] - 'A'+10) * pow(16, pow_up_num);
                    pow_up_num++;
                }
                else if (str[i] >= 'a' && str[i] <= 'f') {
                    res += (str[i] - 'a'+10) * pow(16, pow_up_num);
                    pow_up_num++;
                }
                else {
                    cout << "error input!" << endl;
                    exit(-1);
                }
            }
            cout << res << endl;

        }

        return 0;
    }
    ```

5. 字符串反转
    - 内建函数reverse(s,s.begin(),s.end());记得加头文件#include< algorithm.h >
    - 自己实现reverse函数
```
    void reverse_string(string& s, int start, int end) {
        while (start < end) {
            swap(s[start++], s[end--]);
        }
    }
```

6. 使用排序算法sort(s.begin(), s.end());时候记得加头文件#include< algorithm.h >

7. 单词字典序
```
#include<iostream>
#include<string>
#include<vector>
#include<algorithm>

using namespace std;
int main() {
	int N;
	while (cin >> N) {
		//vector<string> res;
		vector<string> s;
		for (int i = 0; i < N; i++) {
			string str;
			cin >> str;
			s.push_back(str);
		}
		sort(s.begin(), s.end()); // str1 > str2 可以这样对比字符串单词字典序
		for (auto a : s) {
			cout << a << endl;
		}
	}


	return 0;
}
```

8. 正则表达式+stringstream+getline(ss,t,";")分割字符串

[题目：坐标移动](https://www.nowcoder.com/practice/119bcca3befb405fbe58abe9c532eb29?tpId=37&tqId=21240&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D1%26tpId%3D37%26type%3D37&difficulty=undefined&judgeStatus=undefined&tags=&title=)

- getline()的第三个参数默认为空格Enter 可以自行更改
- 使用regex_match要包含头文件 `#include<regex>`
  > https://blog.csdn.net/qq_34802416/article/details/79307102
- 使用stringstream分割字符串需要头文件`#include<sstream>`
  > https://www.cnblogs.com/gamesky/archive/2013/01/09/2852356.html

```
#include<iostream>
#include<string>
#include<regex>
#include <vector>
#include<sstream>
using namespace std;

int main() {
    //ios::sync_with_stdio(false);
    //cin.tie(0), cout.tie(0);
    string s, t;
    while (getline(cin, s)) {
        stringstream ss(s);
        pair<int, int> p(0, 0);
        while (getline(ss, t, ';')) {
            if (t.empty())
                continue;
            string _ = t.substr(1);
            if (regex_match(_, regex("[0-9]*"))) {
                switch (t[0]) {
                case 'A': p.first -= stoi(_); break; //左移
                case 'D': p.first += stoi(_); break; //右移
                case 'W': p.second += stoi(_); break; //上移
                case 'S': p.second -= stoi(_); break; //下移
                default: break; //无效
                }
            }
        }
        cout << p.first << "," << p.second << endl;
    }
    return 0;
}

```

9. ip地址和掩码的判断，地址的分类
主要是几个点要做好判断
	1. 如何输入，ip用什么保存
      	- 因为ip是以键盘输入如：127.26.135.1~255.255.255.0读入，所以使用 ` getline(cin,s,'~') `分别读取前后ip和掩码，
	2. 如何确定是忽略的ip地址，不统计
      	- ip地址的第一个字段转int后为 127 或者 0
	3. 如何识别是错误的ip
      	- 不是合法的ip
         	- ip段为空
         	- ip段大转int后大于255
         	- 不为四个IP段，或少或多
	4. 如何识别是错误的掩码
      	- 掩码由若干个1接上若干个0组成，问题是怎么把一个字符串做识别，可以每次读一个段，然后左移8位，最后存到一个无符号的int类型中，然后用以下代码判断是不是 111..10..01; if条件是指掩码不为全0，掩码不为全1，掩码由若干个1接若干个0
		```
		bool isLegalMask(string ip) {
			istringstream iss(ip);
			string sub;
			unsigned int b = 0;
			//vector<int> v;
			
			while (getline(iss, sub, '.'))  b = (b << 8) + stoi(sub);
			if (b == 0 || b == 0xFFFFFFFF || (((b ^ 0xFFFFFFFF) + 1) | b) != b) {
				return false;
			}
			return true;
		}
		```
	5. 如何获取ip地址的某一个段然后进行ip地址的分类判断
		- ip是以string读ru
		- 使用`#include<sstream>`的istringstream类型作为输入流，然后用while的case功能依次读入每一个段，存到一个vector<int>中即可
		```
		istringstream iss(ip);
			string sub;
			vector<int> sub_vec;
			while (getline(iss, sub, '.')) sub_vec.push_back(stoi(sub));
		```

10. 返回字符串中长度大于2的包含公共元素的最长重复子串

[题目：密码验证合格程序](https://www.nowcoder.com/practice/184edec193864f0985ad2684fbc86841?tpId=37&tqId=21243&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D1%26tpId%3D37%26type%3D37&difficulty=undefined&judgeStatus=undefined&tags=&title=)
- 遍历所有的子串，统计出现次数，暴力搜
	```
	#include<iostream>
	#include<string>
	#include<map>
	using namespace std;

	//暴力破解找最长相同子串
	string findMaxSubStr(string s) {
		string ret = "";
		
		int size = s.size();
		map<string, int> m;
		for (int len = 3; len < size; len++) { //每次check的字符串长度
			for (int pos = 0; pos < size; pos++) {//从最后一个字符串开始算起
				if (pos < size && pos + len < size) {
					string sub = s.substr(pos,len);
					m[sub]++;
				}
				

			}
		}

		for (auto i : m) {
			if (i.second >= 2) ret = i.first;
		}
		return ret;
	}

	//统计字符类型
	int statisticStrType(string s) {
		int A = 0, B = 0, C = 0, D = 0;
		for (auto ch : s) {
			if (ch >= 'a' && ch <= 'z') A=1;
			else if (ch >= 'A' && ch <= 'Z') B=1;
			else if (ch >= '0' && ch <= '9') C=1;
			else D=1;
		}
		return (A+B+C+D);

	}

	int main() {
		string psd;
		while (cin >> psd) {
			if (psd.size() < 9) {
				cout << "NG" << endl;
			}
			else if (findMaxSubStr(psd).size() > 2) {
				cout << "NG" << endl;
			}
			else if (statisticStrType(psd) < 3) {
				cout << "NG" << endl;
			}
			else {
				cout << "OK" << endl;
			}

			
		}
		return 0;
	}
	```
- 只需要遍历所有长度为3的字符串，如果在字符串的其它地方找到了这个串就表示不通过
	> 但是简单的拼接`string ss = s.substr(0, pos) + s.substr(pos + 3)`会出问题,形如`021Aaabcbc$as`这样的密码会被认为NG

	> 所以还是遍历一遍所有的三个子字符串做统计，以此来实现优化
	```
	#include <iostream>
	#include <map>
	#include <string>
	using namespace std;
	int main() {
		string s;
		while (cin >> s) {
			//密码长度需要大于8
			if (s.size() <= 8) {
				cout << "NG" << endl;
				continue;
			}
			//密码至少有四种类型字符的三种
			int A = 0, B = 0, C = 0, D = 0;
			bool flag = false;
			for (auto ch : s) {
				if (ch >= 'a' && ch <= 'z') A = 1;
				else if (ch >= 'A' && ch <= 'Z') B = 1;
				else if (ch >= '0' && ch <= '9') C = 1;
				else D = 1;
			}
			if (A + B + C + D >= 3) {
				flag = true;
			}
			else {
				cout << "NG" << endl;
				continue;
			}
			int size = s.size();
			map<string, int> m;
			//密码不能有大于2包含公共元素的子字符串
			//只需要遍历所有长度为3的子字符串就好
			for (int pos = 0; pos < size; pos++) {//从第一个字符串开始算起
				if (pos < size && pos + 3 < size) {
					string sub = s.substr(pos, 3);
					m[sub]++;
				}
			}
			for (auto i : m) {
				if (i.second >= 2) {
					flag = false;
					break;
				}
			}

				//021Aaabcbc$
			

			if (flag) {
				cout << "OK" << endl;
			}
			else {
				cout << "NG" << endl;
			}
			
		}
		return 0;
	}

	```
11. string::npos用法，参考：https://blog.csdn.net/jiejinquanil/article/details/51789682
	> npos可以表示string的结束位子，是string::type_size 类型的，也就是find（）返回的类型。find函数在找不到指定值得情况下会返回string::npos

12. string or char 的一些方法
	- islower(ch) 'a'~'z'
	- isupper(ch) 'A'~'Z'
	- isalpha(ch) 'a'~'z'+'A'~'Z'

#### vector
1. vector中pair的使用
   > https://www.jianshu.com/p/4b2884c050dc
2. vector::emplace_back() 和 vector::push_back() 

	> emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。
#### 栈和队列
1. 使用队列先进先出的性质，按顺序记录流中的项
   > 题目，[HJ19 简单错误记录](https://www.nowcoder.com/practice/2baa6aba39214d6ea91a2e03dff3fbeb?tpId=37&tqId=21242&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D1%26tpId%3D37%26type%3D37&difficulty=undefined&judgeStatus=undefined&tags=&title=)
   - 暴力解法
     - 如何记录输入`D:\zwtymj\xccb\ljj\cqzlyaszjvlsjmkwoqijggmybr 645` 和这个错误出现的次数
		> 首先要裁剪文件名，最多不超过16个字符，在用一个字符串存文件名，一个int存行号，一个int存出现的次数 所以用vector + pair做记录
		```
		vector<pair<pair<string, int>, int> > record_data;//用来记录出现错误的截断内容，行号，出现的次数
		```
     - 如何维持最新的8个错误
		> 输出记录的最后8条内容
	```
	#include<iostream>
	#include<string>
	#include<map>
	#include<deque>
	#include<vector>
	#include<sstream>
	using namespace std;

	string getFile(string path) {
		istringstream iss(path);
		string sub;
		while (getline(iss, sub, '\\')) continue;
		int size = sub.size();
		if (size > 16) {
			sub = sub.substr(size - 16, size);
		}
		return sub;
	}


	void recordFalt(vector<pair<pair<string, int>, int> >& record_data,string file_name,int line_num) {
		vector<pair<pair<string, int>, int> >::iterator it;
		for (it = record_data.begin(); it < record_data.end(); it++) {
			if (it->first.first == file_name && it->first.second == line_num) {
				it->second += 1;
				return ;
			}
		}
		record_data.push_back(make_pair(make_pair(file_name,line_num),1));
		return;
	}
	
	int main() {
		string path_name;
		int line_num;
		//unordered_map<string, pair<int, int>> map;
		vector<pair<pair<string, int>, int> > record_data;//用来记录出现错误的截断内容，行号，出现的次数
		//vector<pair<string, int>> res;//记录输出截断文件名+行号
		while (cin >> path_name >> line_num) {
			string file_name = getFile(path_name);
			recordFalt(record_data, file_name, line_num);
		}
		vector<pair<pair<string, int>, int> >::iterator it1;
		if (record_data.size() < 8) {
			
			for (it1 = record_data.begin(); it1 != record_data.end(); it1++) {

				cout << it1->first.first << " " << it1->first.second << " " << it1->second << endl;
			}
		}
		else {

			for (it1 = record_data.begin()+(record_data.size()-8); it1 != record_data.end(); it1++) {

				cout << it1->first.first << " " << it1->first.second << " " << it1->second << endl;
			}
		}
		return 0;
	}


	```
   - 使用双端队列deque+map求解, 代码+注释
     - 如何存输入
		> 使用map,一个string存file_name+line来做key,value为这个错误出现的次数
	 - 使用双端队列来维持最新的8个错误，如果deque长度大于8，只要方便地`d.pop_front()`即可
	```
	#include<iostream>
	#include<string>
	#include<map>
	#include<deque>
	#include<vector>
	#include<sstream>
	using namespace std;

	//用双端队列deque+map来做
	int main() {
		//整个行输入做字符串,即file_name+line_num
		string name_line;
		//使用hash映射来存储出现的次数
		map<string, int> m;
		//使用队列维持最新的8个错误
		deque<string> res;
		while (getline(cin, name_line)) {
			//裁取截断文件名+行号
			name_line = name_line.substr(name_line.find_last_of('\\') + 1);
			int pos = name_line.find_last_of(" ");
			if (pos > 16) {
				name_line = name_line.substr(pos - 16);
			}

			//记录错误出现的次数
			if (m.find(name_line) == m.end()) {
				res.push_back(name_line);
			}
			++m[name_line];

			//维持8个在案错误
			if (res.size() > 8) {
				res.pop_front();
			}
		}

		for (auto it : res) {
			cout << it << " " << m[it] << endl;
		}


		return 0;
	}


	```

#### hash表
> 参考：[PiaYie-代码随想录：哈希表](https://www.cnblogs.com/PiaYie/p/15877059.html)

1. 多对一用法：[简单密码](https://www.nowcoder.com/practice/7960b5038a2142a18e27e4c733855dac?tpId=37&tqId=21244&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D1%26tpId%3D37%26type%3D37&difficulty=undefined&judgeStatus=undefined&tags=&title=)
	```
	#include<iostream>
	#include<string>
	#include<unordered_map>
	using namespace std;

	#if 0
	int main() {
		string pwd;
		string res = "";
		while (cin >> pwd) {
			for (auto ch : pwd) {
				if (ch == '1') res+=ch;
				else if (ch == '1') continue;
				else if (ch >= 'a' && ch <= 'c') res += '2';
				else if (ch >= 'd' && ch <= 'f') res += '3';
				else if (ch >= 'g' && ch <= 'i') res += '4';
				else if (ch >= 'j' && ch <= 'l') res += '5';
				else if (ch >= 'm' && ch <= 'o') res += '6';
				else if (ch >= 'p' && ch <= 's') res += '7';
				else if (ch >= 't' && ch <= 'v') res += '8';
				else if (ch >= 'w' && ch <= 'z') res += '9';
				else if (ch >= 'A' && ch <= 'Z') {
					ch = tolower(ch) + 1;
					if (ch == '{') ch = 'a';
					res += ch;
				}
				else res += ch;
			}
			cout << pwd << endl;
		}
		return 0;
	}
	#endif

	#if 1
	//使用map方法只需要判断大小写
	int main() {
		string s;
		unordered_map<char, char> m;
		m['a'] = m['b'] = m['c'] = '2';
		m['d'] = m['e'] = m['f'] = '3';
		m['g'] = m['h'] = m['i'] = '4';
		m['j'] = m['k'] = m['l'] = '5';
		m['m'] = m['n'] = m['o'] = '6';
		m['p'] = m['q'] = m['r'] = m['s'] = '7';
		m['t'] = m['u'] = m['v'] = '8';
		m['w'] = m['x'] = m['y'] = m['z'] = '9';
		while (cin >> s) {
			//原地修改节省空间
			for (int i = 0; i < s.size(); i++) {
				if (islower(s[i])) s[i] = m[s[i]];
				else if (isupper(s[i]) && s[i]!='Z') {
					s[i] = s[i] - 'A' + 'a' + 1;
				}
				if (s[i] == 'Z') s[i] = 'a';
			}
			cout << s << endl;
		}

		return 0;
	}
	#endif


	```


### 暴力破解
1. 质数分解定理
> https://www.cnblogs.com/wellerency/p/15868807.html


![质数分解定理](牛客网华为机试题IDE\HUAWEI_Python_IDE\质数分解定理.png)
- 判定质数和分解质因数
- 边界条件可选 
  - i <= sqrt(N)
  - i <= N/i
```
#include<iostream>
#include<vector>
using namespace std;


//质数分解定理 一个大于1的数其质数分解形式是唯一的。
int main() {

	int N;
	//vector<int> res;
	while (cin >> N) {
		if (N == 1) {
			cout << N << " " << N << endl;
		}
		
		for (int i = 2; i <= N / i; i++) {
			//M*能够整除i
			if (N % i == 0) {
				int cnt = 0;
				while (N % i == 0) {
					cnt++;
					//s.push_back(i);
					N /= i;
					//if (cnt) cout << i << " " << cnt << endl;
					if (cnt) cout << i << " ";
				}
			}
		}
		//if (N > 1) cout << N << " " << 1<< endl;
		if (N > 1) cout << N << endl;
	
	}

	return 0;
}

```
### 快速排序
> 经典排序算法总结：https://www.cnblogs.com/fnlingnzb-learner/p/9374732.html

> 经典排序算法总结（动图）：https://www.cnblogs.com/onepixel/articles/7674659.html

1. 冒泡排序法 $O(n^2)$
![冒牌排序法思路图](牛客网华为机试题IDE\HUAWEI_Python_IDE\mppxf.gif)
```
//冒泡排序
void BubbleSort(int* h, size_t len)
{
    if (h == NULL) return;
    if (len <= 1) return;
    //i是次数，j是具体下标
    for (int i = 0; i < len - 1; ++i)
        for (int j = 0; j < len - 1 - i; ++j)
            if (h[j] > h[j + 1])
                Swap(h[j], h[j + 1]);

    return;
}
```


1. 快速排序 $O(n\log_2 n)$
   - 内建函数 sort(s.begin(), s.end()); 是algorithm中的函数需要头文件
   - 自己实现
```
//快速排序，随机选取哨兵放前面
void QuickSort(int* h, int left, int right)
{
    if (h == NULL) return;
    if (left >= right) return;

    //防止有序队列导致快速排序效率降低
    srand((unsigned)time(NULL));  // include"time.h"
    int len = right - left;
    int kindex = rand() % (len + 1) + left;
    Swap(h[left], h[kindex]);

    int key = h[left], i = left, j = right;
    while (i < j)
    {
        while (h[j] >= key && i < j) --j;
        if (i < j) h[i] = h[j];
        while (h[i] < key && i < j) ++i;
        if (i < j) h[j] = h[i];
    }

    h[i] = key;

    QuickSort(h, left, i - 1);
    QuickSort(h, j + 1, right);
}
```

### 排列组合
### 二分查找
### 递归
### 位运算
### 滑动窗口
### 深度优先算法
### 广度优先算法
### 搜索回溯
### 动态规划
![质数分解定理](牛客网华为机试题IDE\HUAWEI_Python_IDE\动态规划-总结大纲.jpg)
参考：[代码随想录-动态规划](https://www.programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)

1. 背包问题 
> https://www.programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#_01-%E8%83%8C%E5%8C%85
   - 0-1背包
```
//HJ16 购物单问题，即0-1背包的应用题
#include<iostream>
#include<bitset>
#include<vector>
#include <algorithm>
using namespace std;


//因为转移方程dp[i][j]只与dp[i-1][]有关，使用滚动数组讲背包问题的二维dp数组压缩成一维
int main() {
	int N, m;
	while (cin >> N >> m) {
		//输入
		int value, proority, isAttachments;
		
		vector<vector<int>> data(m + 1, vector<int>(6, 0));
		for (int i = 1; i <= m; i++) {
			cin >> value >> proority >> isAttachments;
			if (isAttachments == 0) {
				data[i][0] = value;
				data[i][1] = proority;
			}
			//因为最多只有两附件
			else if (data[isAttachments][2] == 0) {
				data[isAttachments][2] = value;
				data[isAttachments][3] = proority;
			}
			else {
				data[isAttachments][4] = value;
				data[isAttachments][5] = proority;
			}
		}
		//dp[i][j]，表示前i个物品，背包重量(花销)为j的情况下能装的最大价值 n
		//01背包问题 二维数组 dp[i][j]是

		//根据解法我们可以看到，对于任意的dp[i][j]，它只与dp[i−1][  ]（即第i−1行）有关。所以我们可以考虑对dp数组的大小进行优化。 使用单行的dp数组来保存上一行的dp状态，并且大小可以以输入的N为基准。
		vector<int> dp(N + 1, 0);
		for (int i = 1; i < m + 1; i++) {
			for (int j = N; j >0; j--) { //这里只能从N \to 1而不能从 1 \to N 避免溢出
				
				int valuePrime = data[i][0];
				int valueAttach1 = data[i][2];
				int valueAttach2 = data[i][4];
				int prorityPrime = data[i][1];
				int prorityAttach1 = data[i][3];
				int prorityAttach2 = data[i][5];

				//对于每一个主件最多有5种情况 1不买主件(在前一种情况) 2买主件不买附件 3买主件买附件1 4买主件买附件2 5买主件并且买两个附件
				dp[j] = j >= valuePrime ? max(dp[j - valuePrime] + valuePrime * prorityPrime, dp[j]) : dp[j];
				dp[j] = j >= (valuePrime + valueAttach1) ? max(dp[j - valuePrime- valueAttach1] + valuePrime * prorityPrime + valueAttach1 * prorityAttach1, dp[j]) : dp[j];
				dp[j] = j >= (valuePrime + valueAttach2) ? max(dp[j - valuePrime - valueAttach2] + valuePrime * prorityPrime + valueAttach2 * prorityAttach2, dp[j]) : dp[j];
				dp[j] = j >= (valuePrime + valueAttach1 + valueAttach2) ? max(dp[j - valuePrime - valueAttach1 - valueAttach2] + valuePrime * prorityPrime + valueAttach1 * prorityAttach1 + valueAttach2 * prorityAttach2, dp[j]) : dp[j];


			}
		}

		cout << dp[N] << endl;

		//cout << N << " " << m << endl;
	}
	return 0;
}


```
   - 完全背包
2. 子序列问题
- 最长递增子序列，最长递减子序列
	- [例题：合唱队](https://www.nowcoder.com/practice/6d9d69e3898f45169a441632b325c7b4?tpId=37&tqId=21247&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D1%26tpId%3D37%26type%3D37&difficulty=undefined&judgeStatus=undefined&tags=&title=)
	> 最长连续严格递增又递减序列不知道，但是一定有 **最长递增子序列** 属于动态规划知识

	> 正序遍历，dp[i]是包括第i个元素其左边的最长递增子序列包含的元素个数

	> j < i, dp[j]是 `high[j]<high[i]`条件下，的dp值

	> 那么dp序列递推公式为：`dp[i] = max(dp[i],dp[j]+1)`
	```
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < i; j++) {
				if (tall[i] > tall[j]) {
					dp_h[i] = max(dp_h[i],dp_h[j]+1);//这个加1是加的第i个人，因为他比之前的i-1个人（包括j）都高
				}
			}
		}
	```
	> 递减子序列只需要逆序遍历，同样的逻辑即可

	> 最后需要的是最长递增又递减序列，把两个dp数组相加，每个位置多加了自身1次，所以还需要减1
	```
	#include<iostream>
	#include<vector>
	using namespace std;

	int main() {
		int N;
		while (cin >> N) {
			//输入
			vector<int> tall;
			for (int i = 0; i < N; i++) {
				int t;
				cin >> t;
				tall.push_back(t);
			}
			//最长严格递增子序列+最长严格递减子序列->动态规划
			vector<int> dp_h(N, 1), dp_t(N, 1);
			//分两步生成dp数组
			for (int i = 0; i < N; i++) {
				for (int j = 0; j < i; j++) {
					if (tall[i] > tall[j]) {
						dp_h[i] = max(dp_h[i],dp_h[j]+1);//这个加1是加的第i个人，因为他比之前的i-1个人（包括j）都高
					}
				}
			}

			for (int i = N-1; i >= 0; i--) {
				for (int j = N - 1; j > i; j--) {
					if (tall[i] > tall[j]) {
						dp_t[i] = max(dp_t[i], dp_t[j] + 1);
					}
					
				}
			}
			//求和得到最长先增后减子序列长度，但是因为多加了自身一次，要在减去1
			int maxNum = 0;
			for (int i = 0; i < N; i++) {
				if (dp_h[i] + dp_t[i] - 1 > maxNum) {
					maxNum = dp_h[i] + dp_t[i] - 1;
				}
			}
			cout << N - maxNum << endl;

		}

		return 0;
	}
	```

# 其它

1. `#include<algorithm>`中取容器的最大值和最小值方法
	- max_element(first,end,cmp)
	- min_element(first,end,cmp)

	> 返回容器中最小值和最大值的指针。其中cmp为可选择参数, cmp可以是自定义的函数!
	```
	#include<iostream>
	#include<map>
	#include <algorithm>
	using namespace std;

	//定义cmp函数
	bool cmp_value(const pair<int, int> left, const pair<int, int> right)
	{
		return left.second < right.second;
	}

	int main()
	{
		map<int, int> test;
		//初始化
		test.emplace(10, 5);//插入
		test.emplace(3, 17);
		test.emplace(19, 20);
		test.emplace(20, 20);
		//输出按序排列的key值 map原因
		for (auto it : test)
			cout << it.first << " ";
		cout << endl;
		//i是迭代器  返回值为19-20 但只能返回一个迭代器
		auto i = max_element(test.begin(), test.end(), cmp_value);
		cout << i->first <<" " << i->second << endl;
		return 0;
	}

	output:
	19 20
	```
