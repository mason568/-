**动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。**

# 动态规划和贪心算法的区别
- 动态规划：由前一个状态推导
- 贪心：局部直接选最优

# 用DP解题的五步骤
1. 确定dp数组（dp table）以及下标的含义，很重要
2. 确定递推公式（举例推导状态转移公式）
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组（debug不过就把数组打出来一一印证）


# 例题
1. 斐波那契数列
```
#include<iostream>
#include<vector>
using namespace std;

int main() {
	int N;
	while (cin >> N) {
		vector<int> dp(N + 1);//dp[i]为第i个数的斐波那契数值
		dp[0] = 0;
		dp[1] = 1;
		cout << "0 1 ";
		for (int i = 2; i < N + 1; i++) {
			dp[i] = dp[i - 1] + dp[i - 2];
			if (dp[i] > INT_MAX || dp[i]<0) {
				cout <<endl<< "Accept max N as " << i - 1 << endl;
				exit(-1);
			}
			cout << dp[i] << " ";
		}
		cout <<endl<< dp[N] << endl;
	}
	return 0;
}
```

2. 购物单
> [题目来源](https://www.nowcoder.com/practice/f9c6f980eeec43ef85be20755ddbeaf4?tpId=37&tqId=21239&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D1%26tpId%3D37%26type%3D37&difficulty=undefined&judgeStatus=undefined&tags=&title=)

```
#include<iostream>
#include<bitset>
#include<vector>
#include <algorithm>
using namespace std;


#if 0
int main() {
	int N, m;
	while (cin>>N>>m) {
		//输入
		int value, proority, isAttachments;
		vector<vector<int>> data(m + 1, vector<int>(6, 0));
		for (int i = 1; i <= m; i++) {
			cin >> value >> proority >> isAttachments;
			if (isAttachments == 0) {
				data[i][0] = value;
				data[i][1] = proority;
			}
			//因为最多只有两附件
			else if (data[isAttachments][2] == 0) {
				data[isAttachments][2] = value;
				data[isAttachments][3] = proority;
			}
			else {
				data[isAttachments][4] = value;
				data[isAttachments][5] = proority;
			}
		}
		//dp[i][j]，表示前i个物品(任取)，背包容量(花销)为j的情况下能装的 最大价值(权重和)
		//递推函数为 dp[i][j] = max(dp[i-1][j],dp[i-1][j-weight[j]] + value[j])
		//01背包问题 二维数组 dp[i][j]是
		vector<vector<int>> dp(m + 1, vector<int>(N + 1, 0));
		for (int i = 1; i < m + 1; i++) {
			for (int j = 1; j < N + 1; j++) {
				
				int valuePrime = data[i][0];
				int valueAttach1 = data[i][2];
				int valueAttach2 = data[i][4];
				int prorityPrime = data[i][1];
				int prorityAttach1 = data[i][3];
				int prorityAttach2 = data[i][5];

				//对于每一个主件最多有5种情况 1不买主件(在前一种情况,那就是只剩后面四种情况) 2买主件不买附件 3买主件买附件1 4买主件买附件2 5买主件并且买两个附件
				dp[i][j] = j >= valuePrime ? max(dp[i - 1][j - valuePrime] + valuePrime * prorityPrime, dp[i - 1][j]) : dp[i - 1][j];
				dp[i][j] = j >= (valuePrime+valueAttach1) ? max(dp[i - 1][j - valuePrime- valueAttach1] + valuePrime * prorityPrime + valueAttach1 * prorityAttach1, dp[i][j]) : dp[i][j];
				dp[i][j] = j >= (valuePrime + valueAttach2) ? max(dp[i - 1][j - valuePrime- valueAttach2] + valuePrime * prorityPrime + valueAttach2 * prorityAttach2, dp[i][j]) : dp[i][j];
				dp[i][j] = j >= (valuePrime + valueAttach1 + valueAttach2) ? max(dp[i - 1][j - valuePrime- valueAttach1- valueAttach2] + valuePrime * prorityPrime + valueAttach1 * prorityAttach1 + valueAttach2 * prorityAttach2, dp[i][j]) : dp[i][j];


			}
		}

		cout << dp[m][N] << endl;
		
		//cout << N << " " << m << endl;
	}
	return 0;
}
#endif 


#if 1
//使用滚动数组讲背包问题的二维dp数组压缩成一维
int main() {
	int N, m;
	while (cin >> N >> m) {
		//输入
		int value, proority, isAttachments;
		
		vector<vector<int>> data(m + 1, vector<int>(6, 0));
		for (int i = 1; i <= m; i++) {
			cin >> value >> proority >> isAttachments;
			if (isAttachments == 0) {
				data[i][0] = value;
				data[i][1] = proority;
			}
			//因为最多只有两附件
			else if (data[isAttachments][2] == 0) {
				data[isAttachments][2] = value;
				data[isAttachments][3] = proority;
			}
			else {
				data[isAttachments][4] = value;
				data[isAttachments][5] = proority;
			}
		}
		//dp[i][j]，表示前i个物品，背包重量(花销)为j的情况下能装的最大价值 n
		//01背包问题 二维数组 dp[i][j]是

		//根据解法我们可以看到，对于任意的dp[i][j]dp[i][j]dp[i][j]它只与dp[i−1][  ]dp[i-1][\ \ ]dp[i−1][  ]（即第i−1i-1i−1行）有关。所以我们可以考虑对dp数组的大小进行优化。 使用单行的dp数组来保存上一行的dp状态，并且大小可以以输入的N为基准。
		vector<int> dp(N + 1, 0);
		for (int i = 1; i < m + 1; i++) {
			for (int j = N; j >0; j--) { //这里只能从N \to 1而不能从 1 \to N 避免溢出
				
				int valuePrime = data[i][0];
				int valueAttach1 = data[i][2];
				int valueAttach2 = data[i][4];
				int prorityPrime = data[i][1];
				int prorityAttach1 = data[i][3];
				int prorityAttach2 = data[i][5];

				//对于每一个主件最多有5种情况 1不买主件(在前一种情况) 2买主件不买附件 3买主件买附件1 4买主件买附件2 5买主件并且买两个附件
				dp[j] = j >= valuePrime ? max(dp[j - valuePrime] + valuePrime * prorityPrime, dp[j]) : dp[j];
				dp[j] = j >= (valuePrime + valueAttach1) ? max(dp[j - valuePrime- valueAttach1] + valuePrime * prorityPrime + valueAttach1 * prorityAttach1, dp[j]) : dp[j];
				dp[j] = j >= (valuePrime + valueAttach2) ? max(dp[j - valuePrime - valueAttach2] + valuePrime * prorityPrime + valueAttach2 * prorityAttach2, dp[j]) : dp[j];
				dp[j] = j >= (valuePrime + valueAttach1 + valueAttach2) ? max(dp[j - valuePrime - valueAttach1 - valueAttach2] + valuePrime * prorityPrime + valueAttach1 * prorityAttach1 + valueAttach2 * prorityAttach2, dp[j]) : dp[j];


			}
		}

		cout << dp[N] << endl;

		//cout << N << " " << m << endl;
	}
	return 0;
}
#endif


```

